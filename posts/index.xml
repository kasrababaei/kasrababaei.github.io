<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Code &amp; Craft by Kasra</title>
    <link>https://kasrababaei.com/posts/</link>
    <description>Recent content in Posts on Code &amp; Craft by Kasra</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Sep 2025 15:29:17 -0400</lastBuildDate>
    <atom:link href="https://kasrababaei.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Faster Builds by Resolving Protocol Implementations at Runtime</title>
      <link>https://kasrababaei.com/posts/resolve-protocol-implementation-at-runtime/</link>
      <pubDate>Wed, 10 Sep 2025 15:29:17 -0400</pubDate>
      <guid>https://kasrababaei.com/posts/resolve-protocol-implementation-at-runtime/</guid>
      <description>&lt;!-- markdownlint-disable no-inline-html --&gt;&#xA;&lt;p&gt;As iOS projects grow, modularization is key to keeping builds fast and&#xA;dependencies clean. Modularization helps large iOS projects scale by&#xA;keeping code organized and &lt;strong&gt;speeding up incremental builds&lt;/strong&gt;.&#xA;When modules are isolated, small changes only rebuild what’s necessary, leading&#xA;to faster iteration and shorter feedback loops.&lt;/p&gt;&#xA;&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re building a Calculator app where the &lt;code&gt;CalculatorUI&lt;/code&gt; contains the&#xA;UI views and view models, and some of the view models depend on the business logic&#xA;(mathematic operations) that live in the &lt;code&gt;CalculatorBrain&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Making Weak References Thread-Safe in Swift with a Tiny Macro</title>
      <link>https://kasrababaei.com/posts/lockedweakreference/</link>
      <pubDate>Mon, 25 Aug 2025 21:41:54 -0400</pubDate>
      <guid>https://kasrababaei.com/posts/lockedweakreference/</guid>
      <description>&lt;!-- markdownlint-disable no-inline-html --&gt;&#xA;&lt;p&gt;If you’ve worked with delegates in Swift, you’ve almost certainly used &lt;code&gt;weak&lt;/code&gt;&#xA;references. They’re the go-to way to avoid retain cycles—but they come with a&#xA;subtle catch: &lt;strong&gt;they’re not thread-safe&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Now, in a lot of cases, that’s fine. If you only ever touch your delegate on the&#xA;main thread, you’re safe. But what if you want to make your class &lt;code&gt;Sendable&lt;/code&gt; and&#xA;use it across multiple threads in Swift concurrency land? Suddenly, things get messy.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mutual Inclusion by Swift Concurrency</title>
      <link>https://kasrababaei.com/posts/synchronization/</link>
      <pubDate>Tue, 31 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://kasrababaei.com/posts/synchronization/</guid>
      <description>&lt;p&gt;Synchronization refers to the coordination of multiple threads of execution.&#xA;When accessing a shared object, it involves mechanisms to manage mutual&#xA;exclusion—where only one thread can access a critical section at a time—and&#xA;mutual inclusion—where multiple threads can access resources concurrently when&#xA;safe to do so.&lt;/p&gt;&#xA;&lt;p&gt;While using a mutex/lock makes it possible to provide exclusive access to a&#xA;shared mutable state/object, this mutual exclusion isn&amp;rsquo;t always ideal. In some&#xA;cases, multiple threads should be allowed to access the shared state as long&#xA;as some condition is valid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024 in Review</title>
      <link>https://kasrababaei.com/posts/contributions-2024/</link>
      <pubDate>Thu, 26 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://kasrababaei.com/posts/contributions-2024/</guid>
      <description>&lt;!-- markdownlint-disable no-inline-html --&gt;&#xA;&lt;p&gt;As the year comes to an end, I find it’s the perfect time to reflect on&#xA;my accomplishments and contributions in 2024. The year brought unexpected&#xA;twists, such as leaving &lt;a href=&#34;https://www.neofinancial.com&#34;&gt;Neo Financial&lt;/a&gt; and&#xA;embracing new challenges at &lt;a href=&#34;https://www.thescore.com&#34;&gt;theScore&lt;/a&gt;. While&#xA;I achieved several of my goals, a few others remain on my list for the future.&lt;/p&gt;&#xA;&lt;p&gt;Perhaps one of the most unforeseen and significant changes in 2024 was&#xA;my decision to leave Neo. I joined Neo Financial in early 2020, becoming&#xA;part of the iOS team alongside another developer, just one month apart.&#xA;I had the privilege of contributing to the team so early that I was&#xA;there to celebrate its very first release. Over nearly five years,&#xA;I truly enjoyed working with a team of&#xA;exceptionally talented engineers who dedicated their days and nights to&#xA;delivering a groundbreaking product, revolutionizing the banking experience&#xA;for Canadians. However, as difficult as it was, I began reflecting on my&#xA;personal goals and growth trajectory. Seeking a new project that would&#xA;push my boundaries and expose me to fresh challenges, I decided to&#xA;join the Platform team at &lt;em&gt;theScore&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Adding a System-Wide Git Logger on macOS</title>
      <link>https://kasrababaei.com/posts/log-git-commands/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://kasrababaei.com/posts/log-git-commands/</guid>
      <description>&lt;p&gt;Git is both simple and, at times, complicated. While it&amp;rsquo;s initially encouraged to use the command line instead of apps like &lt;a href=&#34;https://www.git-tower.com&#34;&gt;Tower&lt;/a&gt; or &lt;a href=&#34;https://git-fork.com&#34;&gt;Fork&lt;/a&gt;, which offer a user-friendly interface, these apps can sometimes boost productivity. For instance, they provide a visual representation of branches and convenient ways to perform tasks like cloning, pulling, cherry-picking, and rebasing. However, not all of them offer a log or console to monitor the Git commands being executed behind the scenes.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
